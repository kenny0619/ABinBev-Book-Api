import * as mongoose from "mongoose";
import { v4 as uuidv4 } from "uuid";
import * as _ from "lodash";
import * as dateFns from "date-fns";
import { Between } from "typeorm";
import * as fs from "fs";

export class Utils {
  static deleteFolderContents = (folderPath) => {
    if (fs.existsSync(folderPath)) {
      fs.readdirSync(folderPath).forEach((file) => {
        const currentPath = `${folderPath}/${file}`;
        if (fs.lstatSync(currentPath).isDirectory()) {
          Utils.deleteFolderContents(currentPath); // Recursively delete subfolders and files
        } else {
          fs.unlinkSync(currentPath); // Delete files
        }
      });
      console.log(`Contents of folder "${folderPath}" have been deleted.`);
    } else {
      console.log(`Folder "${folderPath}" does not exist.`);
    }
  };

  static shuffleArray = (array) => {
    for (let i = array.length - 1; i > 0; i--) {
      const randomIndex = Math.floor(Math.random() * (i + 1));
      [array[i], array[randomIndex]] = [array[randomIndex], array[i]];
    }
    return array;
  };

  static getRandomStringFromArray(array) {
    if (!Array.isArray(array) || array.length === 0) {
      return null; // Return null if the array is empty or not an array
    }

    const randomIndex = Math.floor(Math.random() * array.length);
    return array[randomIndex];
  }
  /**
   * extracting files
   */

  static readInt(buffer, offset) {
    return buffer.readUInt32LE(offset);
  }

  static readString(buffer, offset, length) {
    return buffer.toString("utf16le", offset, offset + length * 2);
  }

  public static generateRandomNumber(length): number {
    // Generate a random {length} digit code
    return Math.floor(
      Math.pow(10, length - 1) + Math.random() * Math.pow(10, length - 1) * 9
    );
  }

  public static getFileExtension(filename) {
    // Get the last occurrence of the dot (.) in the filename
    const dotIndex = filename.lastIndexOf(".");

    if (dotIndex !== -1 && dotIndex < filename.length - 1) {
      // Extract the substring after the last dot
      return filename.substring(dotIndex + 1).toLowerCase();
    }

    return "";
  }

  public static capitaliseFirst(str: string): string {
    // Generate a random {length} digit code
    return `${str[0].toUpperCase()}${str.substring(1)}`;
  }

  public static getRandomSelectionFromArray = (
    originalArray,
    numberOfItems
  ) => {
    if (numberOfItems > originalArray.length) {
      throw new Error(
        "The number of items requested is greater than the length of the original array."
      );
    }

    // Make a copy of the original array to avoid modifying it
    const shuffledArray = Utils.shuffleArray([...originalArray]);

    // Return a new array with a length equal to numberOfItems
    return shuffledArray.slice(0, numberOfItems);
  };

  /**
   * @param {Number} min
   * @return {Date} The date
   */
  public static addMinToDate(min = 1) {
    const date = new Date();
    const minutes = date.getMinutes() + min;
    date.setMinutes(minutes);
    return date;
  }

  /**
   * @param {Number} hour
   * @return {Date} The date
   */
  public static addHourToDate(hour = 1) {
    const date = new Date();
    const hours = date.getHours() + hour;
    date.setHours(hours);
    return date;
  }

  /**
   * @param {Number} size Code length
   * @return {String} The passcode
   */
  static getAutoGeneratedPasscode = (size = 8) => {
    const characters = "0123456789";
    const charactersArray = characters.split("");
    let selections = "";
    for (let i = 0; i < size; i++) {
      const index = Math.floor(Math.random() * charactersArray.length);
      selections += charactersArray[index];
      charactersArray.splice(index, 1);
    }
    return selections;
  };

  /**
   * @param {Number} size Code length
   * @param {Boolean} alpha Check if it's alpha numeral
   * @return {String} The code
   */
  static generateOTCode = (size = 6, alpha = false) => {
    const characters = alpha
      ? "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
      : "0123456789";
    const charactersArray = characters.split("");
    let selections = "";
    for (let i = 0; i < size; i++) {
      const index = Math.floor(Math.random() * charactersArray.length);
      selections += charactersArray[index];
      charactersArray.splice(index, 1);
    }
    return selections;
  };

  /**
   * @param {String} key the prefix for the id
   * @return {Date} The date
   */
  static generateUniqueId(key: string) {
    return `${key || "key"}-${uuidv4()}`;
  }

  /**
   * convert to uppercase 1st letter
   * @param value
   * @return {Boolean} The code
   */
  static IsObjectId(value) {
    try {
      return (
        value &&
        value.length > 12 &&
        String(new mongoose.Types.ObjectId(value)) === String(value)
      );
    } catch (e) {
      return false;
    }
  }

  /**
   * Add days to a date
   * @param {Date} date The date
   * @param days days to add
   * @return {Boolean} The code
   */
  static addDays(date, days) {
    const result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
  }

  /**
   * modifies mobile with isocode
   * @param {String} mobile
   * @return {String} mobileNoT
   */
  static cleanUpMobileNumber(mobile) {
    let mobileNo = mobile.toString().trim();
    if (mobileNo.substring(0, 1) === "0" && mobileNo.length === 11) {
      mobileNo = `234${mobileNo.substring(1)}`;
    } else if (mobileNo.substring(0, 1) !== "+") {
      mobileNo = `${mobileNo}`;
    }
    // return '2348075889776'
    return mobileNo;
  }

  /**
   * @param {Object} object The payload object
   * @param {String} key to be updated,
   * @return {Object}
   */
  static updateVerification(object, key) {
    const verifications = {
      ...object.verifications,
      [key]: true,
    };
    const verificationCodes = _.omit(
      {
        ...object.verificationCodes,
      },
      [key]
    );
    return { verifications, verificationCodes };
  }

  /**
   * {Date} Generate date range of a single date based on start and end of day
   */
  public static generateSingleDateRange(date: string, dbType = "NoSQL") {
    const startDate = dateFns.startOfDay(dateFns.parseISO(date));
    const endDate = dateFns.endOfDay(dateFns.parseISO(date));

    return dbType === "NoSQL"
      ? { $gte: startDate, $lte: endDate }
      : Between(startDate, endDate);
  }

  /**
   * Generate date range based on give start and end dates
   */
  public static generateDateRange(obj: any, dbType = "NoSQL") {
    try {
      const dateRange = JSON.parse(obj);
      if (dateRange && dateRange.startDate && dateRange.endDate) {
        const startDate = dateFns.startOfDay(
          dateFns.parseISO(dateRange.startDate)
        );
        const endDate = dateFns.endOfDay(dateFns.parseISO(dateRange.endDate));
        return dbType === "NoSQL"
          ? { $gte: startDate, $lte: endDate }
          : Between(startDate, endDate);
      }
      return this.generateSingleDateRange(
        dateRange.startDate || dateRange.endDate || new Date(obj),
        dbType
      );
    } catch (e) {
      return this.generateSingleDateRange(obj, dbType);
    }
  }
}
